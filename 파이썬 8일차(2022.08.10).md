# **추리통계**

모집단 : 전체 집단

모수 : 전체 집단에서 조건에 충족하는 비율

모평균과 모분산을 통틀어 이르는 말

표본 : 샘플링 집단

통계치 : 샘플집단에서 조건 충족하는 비율

표본 분포(Sampling Dristribution)

표본을 여러 번 샘플링하여 평균을 구하고 그 평균으로 모집단의 모수를 추론함

분산.var.() # 모집단평균 - (1-모집단평균)

표준편차.std()

표본분포의 분산 = 모집단의평균 -(1-모집단의평균) / 샘플사이즈

------------------------

## **Bootstrap (부트스트랩)**

- 모집단의 표본을 뽑은 뒤, 표본을 다시 모집단으로 설정하여 표본을 추출

- 가설검정 이전 중복을 허용하여 Random sampling하는 것

- 모집단의 표본을 여러개 추출하면 비용이 많이 들기 때문에, 표본을 바탕으로 샘플링하는것

 ------------------------------------------- 

  

  

## **Array : 배열**

np.array(변수) / np.array([1,2,3]) # 변수에 리스트 넣으면 계산이 편함

백터화연산
```
x = np.array([1,2,3])

x * 2 # [2, 4, 6]                         # List일 경우 [1, 2, 3, 1, 2, 3] 연산 할 수 있으나 복잡하다!

변수 = []                                  # 빈 리스트 생성

np.random.choice(변수, 개수, replace=True) # 표본, 샘플링 할 개수, 중복허용 / 개수만큼 중복 샘플링 진행

random.sample(sequence, k=숫자)            # (시퀀스 = 리스트, 집합, range() 등 , k = 반환될 갯수)
```
  
------------------------------------------------
## **큰 수의 법칙(Law of Large Numbers)**

샘플 사이즈가 커질수록 샘플의 통계치는 모집단의 모수에 가까워진다.

  
-------------------------------------------------------
## **CLT(Central Limit Theorem, 중심극한정리)**

- 모집단의 분포와 상관없이 평균분포가 정규분포를 따른다.

- 샘플 사이즈가 클 수록 표본평균의 분포가 정규분포를 따른다.

- 모집단에서 샘플을 뽑았을 때 정규분포를 따른다!


**용어**
- Confidence Interval(신뢰구간) # 모수가 존재할 가능성이 높은 구간

- 확률 : 신뢰수준95%

- N(뮤,시그마^2) = 정규분포를 나타냄

- Normal Distribution / 가우시안

**비교정리**

- 큰 수의 법칙 : 샘플사이즈가 커질수록 표본평균의 평균이 모수에 가까워진다.

- 중심극한정리 : 샘플사이즈가 커질수록 표본평균의 분포가 정규분포를 이룬다.

  
----------------------------------------------------------------
## **자료 불러오기**
```
pd.read()

encoding = ‘cp949‘ or euc-kr # 한글 인코딩

usecols = [‘a’,‘b’,‘c’] # 컬럼 가져오기

names = [‘바’,‘보’,‘야’] # 가져온 컬럼 이름 설정
```
  

  

## **모집단 랜덤 추출 후 고정 2가지**
```
import random

변수.sample(n=횟수,random_state=정수) # random_state = 정수는 랜덤하게 뽑은 값을 정수번에 고정

-> 1번에 고정하면 아무리 돌려도 똑같은 값 나옴

  

import random

import numpy as np

np.random.seed(정수) # seed = 정수에 값을 고정(위state와 같음)
```
  

  

## **반복문**
```
mean_list = []

for 변수or_값 range(도달할 수): #_는 저장할 필요 없이 반복만 할 때 사용!

변수 = 조건 #반복할 조건

mean_list.append(s1.mean()) # mean_list에 값을 추가
```
  

  

## **히스토그램 만들기**
```
import matplotlib as plt

plt.figure(figsize=(8,5))

plt.hist(pop, alpha=1) # 히스토그램 변수, 크기

plt.axvline(x = pop_mean, c='red', lw=2, label='pop_mean')# 변수, 색상, 굵기, 범주

plt.legend(); # 범례
```
  

  

## **꺽은선 그래프**
```
seaborn.kdeplot() 하는법

import seaborn as sns

sns.kdeplot(data = 변수, x=,y=,cut=0, hut=“변수”,multiple=“그래프채움”)

plt.axvline(x = pop_mean, c='red', lw=2, label='pop_mean')# 변수, 색상, 굵기, 범주

plt.legend()
```
  

  

## **Bar chart**
```
Y = (X축의 변수1, 변수2, 변수3)

X = (Y축의 길이)

plt.bar( X, Y

color =[‘빨’,‘주’,노‘] , alpha = 숫자 # 차트 색, 농도

edgecolor = ‘빨강’, linewidth= 숫자) # 차트 테두리 색, 굵기

plt.xlabel = [‘1이름’,‘2이름’,‘3이름’] # 변수별 이름

plt.xticks(X,xlabel) # 눈금을 적용할 x축의 실제 위치, 해당 위치에 나타낼 값

plt.yticks([10,20,30],[5,10,15]) # 원래 10,20,30 값을 5,10,15로 변경

# xticks(color=’‘,size = , rotation=각도) 가능
```
  

  

## **기타..**
```
np.percentile(변수, ‘퍼센트값’) # 10% =0.1 이런식으로

abs(변수or 정수) # 절대값

정규성 가정 : 데이터가 정규분포를 따르는지 확인 하는 것

정규성 검정 : 30 이상의 데이터는 정규분포에 가까워진다.

=>중심극한정리를 기반으로 모수를 추정하여 계산

np.random.beta(1,9)<-- 베타 찾아보기
```
