### list comprehension
```python
result = []
for I in range(10):
    result.append(i)
>>>> result
[0,1,2,3,4,5,6,7,8,9]

result = [i(a) for i(b) in range(10)]          # 위와 같은 식 축소판 i(b)의 값을 i(a)에 넣어줌
>>>> result  
[0,1,2,3,4,5,6,7,8,9]

result = [i for i in range(10) if  i % 2 ==0]  # 뒤에 if조건식 작성가능 (if문을 필터라고 부름)
>>>> result = [0,2,4,6,8]
```

### Nested For loop
- 2개의 for loop 동시에 사용
```python
word_1 = ‘Hello’
word_2 = ‘World’
result = [ i + j for i in word_1 for j in word_2 ] # for loop 1번실행 후 2번실행
>>> result                                        #(1+1, 1+2, 1+3), (2+1, 2+2, 2+3)... 
[‘HW’, ‘Ho’, ‘Hr’, ‘Hl’, ‘Hd’, ‘eW’, ‘eo’, ‘er’.... ‘ol’,,‘od’ ]
```

### Filter
- Nested에 조건 걸어주기
```python
C_1 = [ ‘A’, ‘B’, ‘C’]
C_2 = [ ‘D’, ‘E’, ‘A’]
result = [ i + j for in c_1 for j in c_2 if not (i==j) ] # i == j가 아닌 데이터만 추가 
>>>>result
[‘AD’, ‘AE’, ‘BD’, ‘BE’, ‘BA’, ‘CD’, ‘CE’, ‘CA’ ]

[ I + j if not(i==j) else i for i in C_1 for j in C_2]   # not(i==j)면 i + j 아니면 i 반환 
```
### Two dimentional list(2차원 목록)
```python
words = "The quuck brown fox jumps over the lazy dog".split() # 단어별 구분
pprint.pprint([ [w.upper(), w.lower(), len(w)] for w in words ]) # 2차원으로 나눠서 저장
>>>result
[[ 'THE', 'the' 3],
 [ 'QUICK', 'quick', 5]... 

-----------------------------

C_1 = [ ‘A’, ‘B’, ‘C’]
C_2 = [ ‘D’, ‘E’, ‘A’]
[[i + j for i in  C_1] for i in C_2]                      # C_2가 먼저 실행, 2차원으로 생성
>>>>result
[ ['AD', 'BD', 'CD'], ['AE', 'BE', 'CE'], ['AA', 'BA', 'CA'] ] # C_2 고정

-------------------------------

[ [i + j for i in C_1 if  i != 'C' ] for i in C_2]            # 2차원 if문 작성요령
>>> result
[['AD', 'BD'], ['AE', 'BE'], ['AA', 'CA']]    
```


### enumerate 
- list의 element를 추출할 때 번호를 붙여서 추출 (index element)
```python
for i, v enmerate("ABC"):       # index, element 형식으로 추출
    print(i, v)
>>> result
0 A
1 B
2 C
------------------------------------
my_str = "ABCD"
{v : i for i, v in enumerate(my_str)}
>>> result
{'A' ; 0, 'B' : 1, 'C' : 2, 'D' : 3}
---------------------------------
list(set(text.split())    # text 단어를 추출해서 / set으로 중복 제거 후 / list생성
```
### zip
- 두 개의 list의 값을 병렬적으로 추출함
```python
alist = ["a1", "a2", "a3"]
blist = ["b1", "b2", "b3"]

[ [a,b] for a, b in zip(alist, blist) ]
>>> result
[['a1', 'b1'], ['a2', 'b2'], ['a3', 'b3']]           # List로 묶어줌

for i, values in enumerate(zip(alist, blist)):   # 인덱스, 그룹
    print(i, values)
[(0, ('a1','b1')), (1, ('a2','b2')), (2, ('a3', 'b3'))]
-----------------------------------
[ c for c in zip(alist, blist) ]                   # Tuple로 묶어줌
>>> result 
[('a1', 'b1'), ('a2', 'b2'), ('a3', 'b3')]   
---------------------------------------------------
math = (100, 90, 80)
kor = (90, 90, 70) 
eng = (90, 80, 70)

[sum(value) / 3 for value in zip(math, kor, eng)]
>>> result
[93.33333333, 86.6666666666, 73.3333333333]

```
----
### Lambda
- 함수 이름 없이, 함수처럼 쓸 수 있는 익명함수
- 수학의 람다 대수에서 유래함
- 코드해석이 어려워서 사용을 지양함
```python
f = (lambda x,y : x + y)                 # lamda 인수 : return
(lambda x,y : x + y)(10, 50)              # 60 

(lambda x : "-".join(x.split()))("My Happy") # ‘My-Happy'
```
### map
- 두 개 이상의 list에도 적용 가능
- 실행시점에 값을 생성하여 메모리 효율적(lambda와 마찬가지로 지양)
```python
ex = [1,2,3,4,5]
f = lambda  x : x**2

list(map(f, ex))           # 반드시 list사용해야함
>>> return
[1, 4, 9, 16, 25]          # [f(value) for value in ex]도 같은결과

list(map(f(x) if x %2 == 0 else x, ex))  # map으로 필터 사용
[ x**2 if x % 2 ==0 else x for x in ex] # for loop 으로 필터 사용
>>> return
[1, 4, 3, 16, 5]

g = lambda x, y : x + y
list(map(g, ex, ex))
>>> return
[2, 4, 6, 8, 10] 
```

### reduce
- list에 똑같은 함수를 적용해서 통합
```python
from functools import reduce
reduce(lambda x, y : x + y, [1, 2, 3, 4, 5]) # 앞의 두 개를 더해서 x를 최신화
>>> result
15  ( 1+2 -> 3+3 -> 6+4 -> 10+5)
```

### iterable object
- 내부적 구현으로 _iter_ 와 _next_가 사용됨
- iter(), next()함수로 iterable 객체를 iterator object로 사용
```python
cities = [ 'seoul', 'bussan', 'jeju']
memory_address_cities = iter(cities)  # 메모리값을 memory_address_cities에 저장
next(memory_address_cities)         # iter() 는 메모리값을 주소에 저장
'seoul'
next(memory_address_cities)         # nex()는 저장된 메모리에서 순서대로 꺼내서 출력
'bussan'
next(memory_address_cities)
'jeju'
```
-----------------

### 단순선형회귀 (Simple Linear Regression)
```python
from sklearn.linear_model import LinearRegression
feature_s = ['sqft_living']   # 특성(feature) 변수지정
target_s = 'price'            # 타겟(label) 변수지정

X = df[feature_s]
y = df[target_s]

simple_ols = LinearRegression() # 선형회귀 변수지정
simple_ols.fit(X,y)             # 선형회귀 훈련
simple = simple_ols.predict(X)  # 훈련된 모델로 특성 지정하여 타겟 예측(타겟 목록)

sns.scatterplot(data = df, x = 특성, y = 타겟)      # 데이터 분포 확인 (y에 예측값 넣으면 선형회귀선처럼 나옴)
sns.lineplot(data = df, x='sqft_living', y= simple) # 선형회귀모델(직선)
sns.regplot(x = 특성, y = 타겟)                     # 스캐터 + 선형회귀 그래프
```
### 다중선형회귀
- 두 개 이상의 독립변수로 종속변수를 설명하는 선형회귀
```python
from sklearn.linear_model import LinearRegression 

feature_m = ['sqft_living','bathrooms']   # 다중 특성값 추출
target_m = 'price'                        # 타겟값 추출

X_m = df[feature_m]
y_m = df[target_m]

multi_ols = LinearRegression()             
multi_ols.fit(X_m,y_m)                     # (특성,타겟) 모델훈련
multi = multi_ols.predict(X_m)             # 훈련된 모델로 X_m특성을 가진 타겟 예측
```
### 회귀평가지표
```python
from sklearn.metrics import r2_score, mean_absolute_error, mean_squared_error # r2 mae mse 임포트

def eval_models(y_pred, y_real=y_real) :         # 회귀평가지표 함수
    mse = mean_squared_error(y_real, y_pred)     # y_real : 실제값( 함수 앞에 미리 지정해둬야함)
    rmse = np.sqrt(mse)                          # y_red : 예측값
    mae = mean_absolute_error(y_real, y_pred)    # 함수에 예측값만 넣어주면 됨 
    r2 = r2_score(y_real, y_pred)

    return mse, rmse, mae, r2
```

### 선형회귀모델의 계수(Coefficients)
```python
model.coef_         # 모델의 회귀계수 (다중이면 feature 순서대로 나옴)
model.intercept_    # 다중회귀 y절편
```


### 함수
```python
np.divide(a,b,c)                  # 나눗셈 a/b ( c에 값을 저장, 미리 선언 필요)

np.cumsum( )                      # array의 누적 합산 값 생성

.keys()			                      # 딕셔너리에서 key 값 뽑아오기
.vlaues()                         # 딕셔너리에서 값 뽑아오기

ab.index                          # 값 대신 index가 저장 됨
df.loc[ab.index,‘colmuns’] =ab    # 인덱스 기억해서 ab를 인덱스,컬럼에 넣어줌

df.iat[a,b]                       # 인덱스번호로 값 대체
df.at[a,b]                        # 인덱스명으로 값 대체

import copy
df2 = copy.deepcopy(df1)                          # df1를 df2에 완전복사(참조x)

np.repeat(‘값’ , 개수)                            # 값을 개수만큼 반복

patients_clean[patients_clean.duplicated(subset=['이름', '전화번호'])] # 중복되는 이름이 여럿인 가운데 동명이인인 경우를 제외한, 동일한 이름과 전화번호를 가진 환자를 확인 

변수 = df[df[‘columns’] > 10]                     # columns이 10보다 큰 값 추출

# 컬럼 여러개 추출
변수 = df[[‘컬럼1’,‘컬럼2’,‘컬럼3’]]               # 필요한 컬럼 추출 
df_a = df.iloc[:,[2,9]]                           # df_a에 df의 2열,9열만 가져오기
pd.DataFrame(df, columns=(‘columns’,‘columns’)  ) # df = 기존에 있는 데이터
df.drop(['B','D'], axis=1)                        # 드롭 사용법

con = (df['GrLivArea']>=1700) & (df['GrLivArea']< 1800)  # 인덱스를 따로 설정하지 않아도 loc가능
df.loc[con, 'SalePrice'].min()  

df3 = pd.concat([df1,df2], axis=0)                   # 데이터 합치기
df5 = pd.merge(df1,df2, on = 'a',how='left')         # a열은 왼쪽 값으로 입력됨
df1.join(df2, how='left', lsuffix='x', rsuffix='y')  # x,y는 조인 대상 Dataframe에 같은 이름의 컬럼이 있으면 에러 발생. 같은 이름이 있는 경우, 붙일 접미어를 지정해준다.

df2 = pd.melt(df, id_vars= df.columns[0:8]|df.columns[12:14], # 가져올 열
value_vars =df.columns[8:12],                                 # 변경할 열
var_name = 'stars',                                           # 카테고리 열 이름
value_name = 'star_name')                                     # 값 열 이름
# a = df.columns[1:2] | df.columns[3:4] 후 a로 입력도 가능 

 # 결측치 제거
df.fillna(0) or df.fillna(np.nan)        # 결측치 특정 문자로 채우기
fillna(method='ffill' or 'pad', limit=number)       # 결측치 앞에거로 채우기, limt(채울갯수 안써도 됨) 
fillna(method='bfill' or 'backfill', limit=number)   # 결측치 뒤에거로 채우기,
df.where(조건,‘바꿀것’)              # 조건에 맞지 않은 것은 ‘바꿀 것’ 안쓰면 Nan표시, 바꿀 것을 쓰면 바꿀것으로 표시
np.where(조건,‘변경1’,‘변경2’)         # 조건에 맞으면 변경1, 틀리면 변경2로 변경
pd.notnull()                          # 결측치가 아니면 True, 결측치면 Fales


sns.displot(df['SalePrice'], kde=True)   # 확률밀도함수
sns. regplot(x=,y=)                      # 회귀선 그래프 
sns.lineplot(x=특성, y=타겟).mean(), color='red') # 기준모델 


```

### 한 번에 여러개 변경하기
```python
abc  = ['값1', '값2', ‘값3']
for i in abc:
    df2['Platform'] = df2['Platform'].str.replace(i, "1")  # I에 abc 값을 넣어서 1로 바꿔줌
    
---------------------------------------------------   


import re   # 여러개 동시에 바꾸기 re.sub (replace와 비슷함) 

컬럼명 = '''010-1234-5678 Kim 
011-1234-5678 Lee 
016-1234-5678 Han'''

text_mod = re.sub('^[0-9]{3}-[0-9]{4}-[0-9]{4}', "***-****-****", 컬럼명) # ^는 선두 1개만 바꾸라는 의미 / flags=re.MULTILINE)를 뒤에 붙이면 모두 변경 가능 {n}은 반복 개수
```
### 문자열에 곱셈 적용하는 방법(단위 결측값 사용할 때)   
- 10k 값을 10/1000으로 바꿔주는 방법   
```python
df.[‘columns’] = df[‘columns’].str.replace('K','000').astype(float)  # K값을 000으로변경(구분하기 쉽게 000)
K_in = df[df['columns'] >10]              # columns에서 10보다 큰 값(데이터프레임)저장 – 구분하기 위해 000 더해줘서 하는 것
K_in = K_index['columns']                 # 바꿀 컬럼 추출
K_1000 = K_index/1000000                  # 10보다 큰 값을 10만으로 나눠줌(1000으로 나눠야하는데 위에서 000 더해서)
df.loc[K_1000.index, 'columns'] = K_1000  # 값을 다시 df에 넣어줌
```
### 문자 앞에 글자 추가하는 방법 (년도 결측값 변경할 때)
```python
df_b = df_a[df_a['columns']<10]     # 10보다 작은 값을 df_b에 저장
df_b = df_b.astype(str)             # df_b를 str로 전환한다.
y200 = '200'+df_b['columns']        # 10보다 작은 수 앞에 200을 붙여서 200x로 만듬
df.iloc[y200.index,‘columns’] = y200
```




